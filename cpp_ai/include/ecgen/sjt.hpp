#pragma once

#include <cppcoro/generator.hpp>
#include <cstdint>
#include <concepts>
#include <ranges>

namespace ecgen {

    /**
     * @brief Steinhaus-Johnson-Trotter algorithm for permutation generation
     *
     * Generates all permutations of length n using the SJT algorithm,
     * which produces each permutation by swapping adjacent elements.
     *
     * @param n Length of permutation
     * @return Generator yielding swap positions (index to swap with index+1)
     */
    auto sjt_gen(int n) -> cppcoro::generator<int>;

    /**
     * @brief Plain Changes algorithm (alternative SJT implementation)
     *
     * Another implementation of the Steinhaus-Johnson-Trotter algorithm
     * using a different recursive structure.
     *
     * @param n Length of permutation
     * @return Generator yielding swap positions
     */
    auto plain_changes(int n) -> cppcoro::generator<int>;

    /**
     * @brief Apply SJT swaps to a container
     *
     * Applies the swaps generated by sjt_gen to a container,
     * yielding each permutation.
     *
     * @tparam Container Type of container (must support random access and swapping)
     * @param n Length of permutation
     * @param container Reference to container
     * @return Generator yielding reference to container after each swap
     */
    template<typename Container>
    auto sjt_apply(int num, Container& container) -> cppcoro::generator<Container&> {
        co_yield container;
        for (int swap_pos : sjt_gen(num)) {
            std::swap(container[swap_pos], container[swap_pos + 1]);
            co_yield container;
        }
    }

    /**
     * @brief Number of permutations (factorial)
     *
     * @tparam N Length of permutation
     * @return constexpr std::size_t N!
     */
    template<std::integral T>
    constexpr auto factorial(T num) -> std::size_t {
        std::size_t result = 1;
        for (T idx = 2; idx <= num; ++idx) {
            result *= idx;
        }
        return result;
    }

} // namespace ecgen
