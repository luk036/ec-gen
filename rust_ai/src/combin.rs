//! Combinations Generator
//!
//! This module provides functions for working with combinations in mathematics.
//! A combination is a way of selecting items from a larger set where the order doesn't matter.
//! The main purpose is to calculate the number of possible combinations and generate
//! all possible combinations for a given set of elements.
//!
//! The code takes two main inputs: 'n', which represents the total number of elements
//! in a set, and 'k', which represents how many elements we want to choose from that set.
//!
//! The 'emk' function generates all combinations by starting with a list of 'k' ones
//! followed by 'n-k' zeros, then repeatedly swapping elements based on the pairs
//! generated by 'emk_comb_gen'. This allows it to produce all possible combinations
//! without having to store them all in memory at once.

use genawaiter::{sync::gen, yield_};
use std::collections::HashMap;
use std::sync::Mutex;
use lazy_static::lazy_static;

lazy_static! {
    static ref COMB_CACHE: Mutex<HashMap<(i32, i32), i32>> = Mutex::new(HashMap::new());
}

/// Calculate the number of combinations of `k` elements from a set of `n` elements.
///
/// # Arguments
///
/// * `n` - Total number of items available for selection
/// * `k` - Number of items to choose from the set
///
/// # Returns
///
/// The number of combinations of `n` items taken `k` at a time.
///
/// # Examples
///
/// ```
/// use rust_ai::combin::comb;
///
/// assert_eq!(comb(6, 3), 20);
/// assert_eq!(comb(6, 4), comb(6, 2));
/// assert_eq!(comb(6, 5), comb(6, 1));
/// assert_eq!(comb(6, 6), comb(6, 0));
/// ```
pub fn comb(n: i32, k: i32) -> i32 {
    if k >= n || k <= 0 {
        1
    } else {
        comb_recur(n, k)
    }
}

fn comb_recur(n: i32, k: i32) -> i32 {
    let key = (n, k);
    {
        let cache = COMB_CACHE.lock().unwrap();
        if let Some(&value) = cache.get(&key) {
            return value;
        }
    }
    
    let result = if k == 1 {
        n
    } else if k == n - 1 {
        n
    } else {
        comb_recur(n - 1, k - 1) + comb_recur(n - 1, k)
    };
    
    let mut cache = COMB_CACHE.lock().unwrap();
    cache.insert(key, result);
    result
}

/// Generate all combinations by homogeneous revolving-door algorithm.
///
/// Generates pairs of indices `(x, y)` that represent swaps to perform
/// to generate all combinations.
///
/// # Arguments
///
/// * `n` - Total number of elements in the set
/// * `k` - Number of elements to be selected in each combination
///
/// # Returns
///
/// A generator that yields pairs of integers `(x, y)` representing swaps.
///
/// # Examples
///
/// ```
/// use rust_ai::combin::emk_comb_gen;
///
/// for (x, y) in emk_comb_gen(6, 3) {
///     println!("swap {} and {}", x, y);
/// }
/// ```
pub fn emk_comb_gen(n: i32, k: i32) -> impl Iterator<Item = (i32, i32)> {
    gen!({
        if k >= n || k <= 0 {
            return;
        }
        if k == 1 {
            for i in 0..(n - 1) {
                yield_!((i, i + 1));
            }
            return;
        }
        if k % 2 == 0 {
            for pair in emk_gen_even(n, k) {
                yield_!(pair);
            }
        } else {
            for pair in emk_gen_odd(n, k) {
                yield_!(pair);
            }
        }
    })
    .into_iter()
}

fn emk_gen_even(n: i32, k: i32) -> impl Iterator<Item = (i32, i32)> {
    gen!({
        if k >= n - 1 {
            yield_!((n - 2, n - 1));
        } else {
            for pair in emk_gen_even(n - 1, k) {
                yield_!(pair);
            }
            yield_!((n - 2, n - 1));
            if k == 2 {
                for i in (0..=(n - 4)).rev() {
                    yield_!((i, i + 1));
                }
            } else {
                for pair in emk_neg_odd(n - 2, k - 1) {
                    yield_!(pair);
                }
            }
        }
        yield_!((k - 2, n - 2));
        if k != 2 {
            for pair in emk_gen_even(n - 2, k - 2) {
                yield_!(pair);
            }
        }
    })
    .into_iter()
}

fn emk_gen_odd(n: i32, k: i32) -> impl Iterator<Item = (i32, i32)> {
    gen!({
        if k < n - 1 {
            for pair in emk_gen_odd(n - 1, k) {
                yield_!(pair);
            }
            yield_!((n - 2, n - 1));
            for pair in emk_neg_even(n - 2, k - 1) {
                yield_!(pair);
            }
        } else {
            yield_!((n - 2, n - 1));
        }
        yield_!((k - 2, n - 2));
        if k == 3 {
            for i in 0..(n - 3) {
                yield_!((i, i + 1));
            }
        } else {
            for pair in emk_gen_odd(n - 2, k - 2) {
                yield_!(pair);
            }
        }
    })
    .into_iter()
}

fn emk_neg_even(n: i32, k: i32) -> impl Iterator<Item = (i32, i32)> {
    gen!({
        if k != 2 {
            for pair in emk_neg_even(n - 2, k - 2) {
                yield_!(pair);
            }
        }
        yield_!((n - 2, k - 2));
        if k < n - 1 {
            if k != 2 {
                for pair in emk_gen_odd(n - 2, k - 1) {
                    yield_!(pair);
                }
            } else {
                for i in 0..(n - 3) {
                    yield_!((i, i + 1));
                }
            }
            yield_!((n - 1, n - 2));
            for pair in emk_neg_even(n - 1, k) {
                yield_!(pair);
            }
        } else {
            yield_!((n - 1, n - 2));
        }
    })
    .into_iter()
}

fn emk_neg_odd(n: i32, k: i32) -> impl Iterator<Item = (i32, i32)> {
    gen!({
        if k == 3 {
            for i in (0..=(n - 4)).rev() {
                yield_!((i + 1, i));
            }
        } else {
            for pair in emk_neg_odd(n - 2, k - 2) {
                yield_!(pair);
            }
        }
        yield_!((n - 2, k - 2));
        if k >= n - 1 {
            yield_!((n - 1, n - 2));
        } else {
            for pair in emk_gen_even(n - 2, k - 1) {
                yield_!(pair);
            }
            yield_!((n - 1, n - 2));
            for pair in emk_neg_odd(n - 1, k) {
                yield_!(pair);
            }
        }
    })
    .into_iter()
}

/// Generate combinations by swapping pairs of integers using the EMK algorithm.
///
/// # Arguments
///
/// * `n` - Total number of elements in the combination
/// * `k` - Number of ones in each combination
/// * `zero` - Value that represents a zero in the generated combinations (default: 0)
/// * `one` - Value that represents a one in the generated combinations (default: 1)
///
/// # Returns
///
/// A generator that yields vectors representing each combination.
///
/// # Examples
///
/// ```
/// use rust_ai::combin::emk;
///
/// for s in emk(6, 3, "◾", "◽") {
///     println!("{}", s.join(""));
/// }
/// ```
pub fn emk<T: Clone>(n: i32, k: i32, zero: T, one: T) -> impl Iterator<Item = Vec<T>> {
    gen!({
        let mut s = vec![one.clone(); k as usize];
        s.extend(vec![zero.clone(); (n - k) as usize]);
        yield_!(s.clone());
        
        for (x, y) in emk_comb_gen(n, k) {
            s.swap(x as usize, y as usize);
            yield_!(s.clone());
        }
    })
    .into_iter()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_comb() {
        assert_eq!(comb(6, 3), 20);
        assert_eq!(comb(6, 4), comb(6, 2));
        assert_eq!(comb(6, 5), comb(6, 1));
        assert_eq!(comb(6, 6), comb(6, 0));
    }
    
    #[test]
    fn test_emk_comb_gen() {
        let pairs: Vec<_> = emk_comb_gen(6, 3).collect();
        assert_eq!(pairs.len(), 19); // C(6,3) - 1 swaps
        
        // Check first few swaps
        assert_eq!(pairs[0], (2, 3));
        assert_eq!(pairs[1], (1, 2));
        assert_eq!(pairs[2], (0, 1));
    }
    
    #[test]
    fn test_emk() {
        let combinations: Vec<_> = emk(6, 3, 0, 1).collect();
        assert_eq!(combinations.len(), 20); // C(6,3) combinations
        
        // Check first combination
        assert_eq!(combinations[0], vec![1, 1, 1, 0, 0, 0]);
        
        // Check last combination
        assert_eq!(combinations[19], vec![0, 0, 0, 1, 1, 1]);
    }
}
