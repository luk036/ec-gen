//! Binary Reflected Gray Code Generator
//!
//! This module implements a Gray code generator, which is a sequence of binary numbers
//! where each successive number differs from the previous one by only one bit.
//!
//! The `brgc_gen` function generates a sequence of numbers representing which bit
//! to flip in order to create the Gray code sequence.
//!
//! The `brgc` function uses the sequence generated by `brgc_gen` to create the
//! actual Gray code by starting with a list of n zeros and then flipping the bits
//! according to the sequence.

use genawaiter::{sync::gen, yield_};

/// Generate a sequence of binary reflected Gray code numbers up to a given length `n`.
///
/// Each number in the sequence indicates which bit position to flip to get the next Gray code.
///
/// # Arguments
///
/// * `n` - Number of bits in the binary reflected Gray code sequence
///
/// # Returns
///
/// A generator that yields integers representing bit positions to flip.
///
/// # Examples
///
/// ```
/// use rust_ai::gray_code::brgc_gen;
///
/// for i in brgc_gen(4) {
///     println!("flip {}", i);
/// }
/// ```
pub fn brgc_gen(n: i32) -> impl Iterator<Item = i32> {
    gen!({
        if n == 1 {
            yield_!(0);
            return;
        }

        for idx in brgc_gen(n - 1) {
            yield_!(idx);
        }
        yield_!(n - 1);
        for idx in brgc_gen(n - 1) {
            yield_!(idx);
        }
    })
    .into_iter()
}

/// Generate a binary reflected Gray code sequence of length `n`.
///
/// # Arguments
///
/// * `n` - Number of bits in the binary code
///
/// # Returns
///
/// A generator that yields vectors of 0s and 1s representing each Gray code.
///
/// # Examples
///
/// ```
/// use rust_ai::gray_code::brgc;
///
/// for lst in brgc(4) {
///     println!("{:?}", lst);
/// }
/// ```
pub fn brgc(n: i32) -> impl Iterator<Item = Vec<i32>> {
    gen!({
        let mut lst = vec![0; n as usize];
        yield_!(lst.clone());

        for idx in brgc_gen(n) {
            lst[idx as usize] = 1 - lst[idx as usize]; // flip
            yield_!(lst.clone());
        }
    })
    .into_iter()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_brgc_gen() {
        let flips: Vec<_> = brgc_gen(4).collect();
        let expected = vec![0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0];
        assert_eq!(flips, expected);
    }

    #[test]
    fn test_brgc_gen_small() {
        let flips: Vec<_> = brgc_gen(1).collect();
        assert_eq!(flips, vec![0]);

        let flips: Vec<_> = brgc_gen(2).collect();
        assert_eq!(flips, vec![0, 1, 0]);
    }

    #[test]
    fn test_brgc() {
        let codes: Vec<_> = brgc(3).collect();
        assert_eq!(codes.len(), 8); // 2^3 = 8

        // Check first code
        assert_eq!(codes[0], vec![0, 0, 0]);

        // Check second code (flip bit 0)
        assert_eq!(codes[1], vec![1, 0, 0]);

        // Check third code (flip bit 1)
        assert_eq!(codes[2], vec![1, 1, 0]);

        // Check all codes are unique
        let mut sorted = codes.clone();
        sorted.sort();
        sorted.dedup();
        assert_eq!(sorted.len(), 8);
    }

    #[test]
    fn test_brgc_gray_code_property() {
        let n = 4;
        let codes: Vec<_> = brgc(n).collect();

        // Check Gray code property: consecutive codes differ by exactly one bit
        for i in 0..codes.len() - 1 {
            let diff_count = codes[i]
                .iter()
                .zip(codes[i + 1].iter())
                .filter(|(a, b)| a != b)
                .count();
            assert_eq!(
                diff_count,
                1,
                "Codes {} and {} differ by {} bits",
                i,
                i + 1,
                diff_count
            );
        }
    }
}
